Okay folks, can you hear me cool? Well, welcome to 168. We're going to talk today about routing. I'm going to remind you who I am because I'm clearly not Sylvia. I'm Rob Shakir. I'm a network engineer at well, networks software engineer at Google. I have been involved in running networking things for some time. I'll give you a very brief not to indulgent track through what that involves. This is me. Nobody ever asked for a different picture of me. They asked for a different picture of my dog. So here's my dog. She's called Heloise. She's really cute. She would come to lectures, but you would not study anything to do with networking if she was here. So I've been working now, I think for 20 years in networking, which I wouldn't have thought I would have said I started out being this tiny little.in running a network in London for this tiny start up, I then came out of university, decided start up is not really growing as quickly as I would like, and instead went to go and work in a small network service provider doing sort of business, Internet services. Then got involved in a bigger network that was called Cable and Wireless that had some networks abroad. And then I went to work for British Telecom, which did had networks in 180 countries. I'm going to admit I didn't count that this is 180 countries, it might be more. But basically, I've been involved in building networks like this through just kind of doing things. And then in 2015, I moved to the US and I took a job at Google in 2016. And so now I'm part of the team that builds this infrastructure that supports both GCP, so that's the cloud platform as well as supports the rest of Google's networks, so all the search products, et cetera. We do a lot of different types of infrastructure. So we build the networks that are connected, data centers, we connect to other ISP's, we connect to our customers, for cloud customers, and we also do a lot of things like undersea networking. So this is the cool bit that everybody always asks about. And when we've talked about optical, I think it's maybe not clear what optical sometimes means. Optical is running glass underneath, you know, terrestrially or underneath the ocean to carry networking signals. So this bit of networking looks actually like this, right? So it's going and putting cables out in the ocean, running them on these boats. This is a cable landing on the beach. These are the kind of size of the cable. It's got a set of, this is an amplifier that's in the cable and this is what runs under the ocean. So my team does everything from running these kind of cables to running the software that runs the network. So I'm going to admit I've never been in a networking class. This is the first networking class that I've been in. So I'm going to teach the material maybe with a slight view of sometimes just going, and it actually works like this. And we've simplified here, so I'll kind of talk through it like that. So today we're going to talk about one of the fundamental problems which is routing. So we've talked a lot about, you know, a top down view of how the Internet works in a bottom up view of the Internet. And kind of said like, oh well host A and host B communicate some way. We haven't really said how they communicate and how we choose which path they take for it, so that's what routing is. I'm going to start out with a couple of disclaimers, then we're going to go through and think about how we're going to think about addressing today. We'll come back and look at IP addressing in a couple of lectures time. We're going to talk a little bit about what is a router. And again, we'll come back in a couple of lectures time and talk a bit more about what a router actually looks like. Um, why we have routers, what the challenges of routing, the challenges of forwarding, and what the difference between those two things are. We'll talk a bit about routing validity and then we're going to try it in class activity. And hopefully we're going to get through all of these things by 430 when we're going to start that and try and do a quiz. So a disclaimer. There's a lot of different solutions to routing. There's a lot of ways that you can pick paths through a graph to be able to choose how to root between two hosts. We're going to generally focus on what we call the archetypal Internet. So we're really going to think about what today's Internet looks like and we're going to make some simplifying assumptions. And we'll discuss them as we go along. And we'll talk about some of the alternative ways that routing can work next week. The second disclaimer is, I'm British and I say routing in America, you say routing. When you say routing, I think of this which is cutting grooves in wood. That's a router. To me, a router is what forwards packet. These two things are interchangeable. I think only as Brits say routing. I'm going to say routing because I've tried to adjust multiple times and I can't manage it. Let's think about back to when we were thinking about transferring data. We were thinking about packets. So what did a packet have in it? Had some level of metadata and then it had the payload. You know, when we were talking about moving that image, there was some series of bits that were carrying that image between two destinations. But we're really interested in the metadata. We don't really care what's in the packet for routing, we care about the metadata. And so the meta data must contain a destination address, so we need to know where we're going to actually carry this packet to, who is it going to? The metadata necessarily must have a destinatd address, which implies that hosts have some form of addresses, or maybe even more than one. Can we think of why a host might have more than one address? It could have multiple interfaces, multiple ports on it which would give different addresses. Any other reasons, redundancy yet? Similar. Could have multiple ports. Yeah. Could have something in front of it that changes its address equally. It could just be connected to multiple networks like so your cell phone, it's probably connected to the Wi as well as to cellular. And it has a different addresses because it's connected to different networks. But for now we're just going to simplify and say there's just one address per host because it makes it a bit easier for us to think about when we draw a host. Throughout this, we're going to draw this letter in a circle that host is thought about with the address of in this case. And we're just going to not worry about what the address actually is. We're just going to think about these letters to start with, because it'll let us think about the problem of routing independently to the problem of addressing. Okay, so we've said the root. I've, I've said the word router a few times, apparently. I can't say that sentence though. Let's actually think about what it is. If we think about this picture that we've drawn before. We've got different networks with end hosts in them. We've got links that connect them together. And then we've got some switches. We switches and routers, essentially the same thing. I think Sylvia covered it earlier, kind of said, oh, yeah, there's historically been some difference, but today we can kind of think of them as the two thing and we can define a router. If you look in all of these diagrams, then the router has some things connected to it. So we can say that the router is an intermediate node that's usually connected to multiple neighbors. It doesn't have to be, but it usually is. But it's definitely an intermediate nodes. It's not the end host itself. It's some node that carries, that is getting us to that end host. When we draw them, we're going to draw them either as these squares or these circles. I'll try and stick to the squares, but a network engineer might draw this because this is the picture that's usually used in diagramming applications to show a router when you're drawing out a network topology. So when you're drawing out the graph, this is actually the Cisco picture that was used as a router. But a router might also be this. Like the kind of thing you'd have in your home which, which has Wi Fi interfaces as well as wired interfaces. It could be this, this would be a very small router, but then they also come in different sizes. So you're going to have a banana for scale down here. And they get up to about human sized or slightly larger than that. We'll go through and we'll in the future talk about what's actually inside these boxes. But today they look like this. Let's think about why we have routers. We have these two hosts, A and B. We want to be able to connect them together, so we add a link. It seems simple enough. But then if we have more hosts, what do we do? How do we connect these together? Well, the simplest thing we could do is just go and create links between all of them like this. We'd call this a full mesh where every endpoint is connected to every other endpoint. Is there a problem with this approach? We reckon connections seems reasonable. If we have to do this at the scale of the Internet, probably we're going to have a lot of wires and physically running all those wires is really going to be quite difficult. So it'd be rather impractical if when you wanted to connect to the Internet you had to have a wire that goes to every other host that was, that was on the internet. And it'd be really difficult when we added a new host because we have to go to everybody's house and rewire the whole planet. Also, what do we do in this case when a link fails? If we had that approach, we have to think about like how would we carry traffic if we're relying on that sort of full mesh of wires? How would we carry traffic in that case? But is there anything good about this approach? Is there anything good about having this full mesh of connectivity? Yeah, exactly. Like everybody can reach everybody. We know that that's something that we could probably achieve with some other sort of aggregation. But we also have a lot of bandwidth, right? Like when we think about connectivity, then we connect to each other. Sorry. Yeah, there's no one in the middle. If these are each physical wires, then yeah, like to read what's on that cable, you'd have to have access to that cable. There's no one in the middle who can send sniff the traffic. So yeah, there's some advantages to this, I would say it's building this kind of mesh of connectivity really gives you, the main reason you might do it is for a lot of bandwidth. So everybody can, has the full capacity to everybody else. If A wants to send to B at the same time as D sends to E, that's fine. They can still use the full bandwidth of the links that we've made available. And that wouldn't be the case if we did something like this. If we built this chain of devices and we said there's one wire and everyone's connected to it and we had some way to be able to control who sends on it. Well now we would only have the bandwidth of one specific wire here, and everybody would have to figure out how to use that bandwidth efficiently. So we might build a topology that looks like this. So here we've added some routers, so we've said D connects to this router, A connects to this one, and C and B also do. And so this gives us some way to build less wires so that we're getting some aggregations. Way fewer links. Here, we only had one link per host. Solve that scalability problem as well. But there's more capacity than just a single link. If we had that single link where everybody had to share it, then you would only be able to utilize that bandwidth once. Now we've got some cases where here A consent to and to consent to D without crossing each other so we can use more of the bandwidth. We can also have alternate paths here. We can say, oh, is still sending to D, but this link here failed. Now this router here as an intermediate node, can say, oh, I know how to get to D and carry traffic via this alternate route. We get some resilience in the network too, where if links fail, we're able to actually carry, still carry traffic. So we can't mention there that, well, the router decides how to send traffic. So now we can talk about what is routing and what is the challenge of routing. Really, we can break it down to this. When a packet arrives at a device, at a router, we have to figure out where should it go? Like in this case, the packet arrives at our two. Does it send it to R one or R three? Because it has to eventually arrive at the same destination. And in this case, R two is not connected to that destination. So we want to find paths that are good for some definition of good. There's arbitrary definitions of good, so we'll come onto them later on as we discuss routing in a bit more detail. But you might think that good short right, like we might want to use the fewest links possible. So there's different ways that we can look at. Good. We probably don't want to just have random routing. We probably don't want to just, you know, accept a packet and then send it via some random link and hope that it gets there. And we probably don't want to send a packet to everybody. Because if we did that, if we received a packet and we sent it to every single neighbor that might possibly be connected it, then we'd use a lot of bandwidth, inefficiently use the resources that are available of the network. We also want to be able to have this approach of choosing a path adapt to arbitrary apologies. So you can see here that, you know, where as we were looking at a fairly simple network before, this one's got a bunch of different routers in it. It's, you know, the graph has got a bunch of different ways that you might traverse it. And what we call the graph of a network is the topology of the network. So how it connects together, what links and what nodes there are, is the topology. And that graph can vary a lot. For example, this is a little bit of historical picture of Up, which was a network that is now part of horizon, that this is a North American network. And you can see that they have a very meshy network with a lot of high bandwidth connections, some lower bandwidth connections, international connections. But networks might always also look like this. So this would be a enterprise network. This is a Cisco diagram. So you can see here we've got a little Cisco rooted image. And in this case the graph is a little less complex, right? Like basically everyone connects back to this head office, even for the same geography. So if we look at Century Link or another Internet service provider, like they have a similar, a similar footprint as the network we looked at, but they have a different topology. They have different cities that they go to, they have different ways of connecting them together. And routing needs to be able to work across all of these. They also need to be able to deal with these kind of very structured data, very structured topologies. So this is a small data center network. Small because we can fit on this graph, like at Google, we don't draw the whole thing because it doesn't fit on the slide. And so here this would be a lot of connections. You can see it's very meshy and we need routing to be able to also deal with this kind of topology. So this is the variety of topologies that we might have to deal with. And when we look at the Internet, this is a project called Opti, where a guy, Barrett Lyon, he tries to map the internet. And so this is a picture, I think it's the 2010 Internet, might be, have been updated since then. And you can see here that there's, you know, very meshy parts in the middle. But when we get out to the edges, we've got these kind of clusters of networks around it. And so the routing problem also needs to scale to this kind of complexity of graph. What's the challenge? We want to find those paths that are good. We want to adapt to arbitrary topologies. The different networks that we have also use different types of routing. You can imagine that the data center network that we had with a very structured topology might have different requirements to the more sparse graphs that we have for things like the US domestic network. We also have to deal with the fact that every topology is dynamic. Can we think topologies might be dynamic? Yeah, absolutely. So adding customers to the network, every time we add a customer, then we're going to add some new link to it. Adding locations to our network, links failing. You know, there's lots of people thinking lots of holes with back holes right now. The main cause of link outages in a Wan network is people cutting through links physically. So yeah, we have to be able to deal with that. We've talked about routing, we separate routing and forwarding. The basic challenge of routing, we said was basically like, where do we send a packet? But the basic challenge of forwarding is a little bit different. We start for the same way and when a packet arrives. The router forwards the packet to one of its neighbors. The result of the, of where to root it is to where to forward the packet. The decision here needs to be made really fast. We might have nanoseconds to make that on link speeds that we have today. We have to choose where to send that packet very, very quickly. Which implies that the decision process for where and how to forward is very simple. Because if it was very complex, we probably can't do it in nanoseconds. The solution to that is to use a table. We'll talk about two different setups of table here, but they work out the same thing here. We're looking root two and it's the table that has for a certain set of destinations, you'll see A, B, C, and D, they're all our hosts. What is the next top? And the next top essentially just means who am I going to forward it to? Who is the decision? That's the next person that I forward it to. Here you can see that B is going to go to R three because it's connected there, and C is also going to go to three. When we think about a router, in terms of forwarding, it really doesn't care necessarily about who it sends to next. It really cares about which port it's going to send out. So that can be the next thing that we look at than writing this table in terms of what the router that it corresponds to. We can write it in terms of what port it's going to go out of because exsally when we've made the decision, that's where we're going to put the packet and put it onto the wire. Today, we'll kind of simplify here and say there is only ever one neighbor on a link. These two things are essentially analogous. Historically, that wasn't really the case, actually, in modern networks, this is the case. So it's not really a particularly simplifying assumption, it's just how the reality, But used to be, we don't really talk about there being multiple hosts connected. All right, so when we're forwarding with the table, if we look at these tables, we only have the destination and the next top. So the decision that we're making is really just based on the destination field of the packet we're going to look up from the packet that we drew out before. We're not going to look at anything other than the destination device address. And then we're going to choose where the packet goes based solely on that. That's really the most common way of doing routing, but it's not the only way you can imagine that we might look at more than just the destination address. But today's Internet solely works on the destination address, so we don't do forwarding through the network, make routing decisions based on anything other than the destination inside particular networks. You might do that for various different reasons, but we can kind of just think about destination based routing today. So let's just compare the two. So what do we do? We look up the packets destination, the table, and then we choose which neighbor to send that to. But routing otherwise instead communicates with other routers to determine how to populate those forwarding tables. So it's choosing how to build the table that we looked at here. You know, forwarding didn't tell us how to do this, it just used the table that existed. But rooting tells us actually how to populate it. Forwarding is inherently local. So when we're talking about how, you know, that forwarding decision that we made, all we cared about was where is the next top connected to me. We didn't say anything about what the graph looks like. We didn't say anything about the downstream of that next device. We just said, okay, I'm going to send it to the next device. So it's really a local decision. So it depends on the arriving packet and the local table and how that's populated. So here we get a packet for B. We solely look at B and we choose that it's going to go out of port one, so we forward out port one. And we can look at that solely in terms of this, in terms of the local table, but for rooting we have to know about all destinations. So we need to know what the graph looks like to find out where all the hosts are. When we talked about this here, you know none of these hosts ABCOD are connected to our two, but we needed to know about them. So routing is inherently a global problem. And we'll talk a bit about global and how exactly how global global means as we go on here. Again, sorry, just reiterating this. Point B here is not connected to our two, but it needs to know how to get there. So it needs to know about all these destinations, forwarding and routing are implemented by different parts of a router. And we'll talk about what these parts look like in a bit more detail in a couple of vectures time. But we can say that forwarding is the primary responsibility of the data plane of a router, Routers data plane, its job is to do forwarding, is to make those forwarding decisions. But the control plane, which is sort of where the brain of the router is deciding, making these routing decisions, communicating with other devices, and figuring out how to place traffic. They also have different time scales. So, you know, on the forwarding perspective we said, well, we might end up with packets that arrive and we have nanoseconds to make a decision. And so at 400 gigabites of second, that's a lot of packets that arrive per second. And so you have to make that decision quickly. But routing, we only really need to do something when the topology of the network changes. You know, when a customer is added, when a link fails. So the graph only needs to be modified at that time scale. So these two different parts of the router, this data plane and control plane, are actually optimized for different things. They're optimized to, you know, this one's optimized to make sure that it can deal with the timescale of the failures and do those computations. This part is optimized to bile, to do very simple things very, very quickly. Okay, so now we talked a little bit about routing and what it is and what the difference to forwarding. Let's think about how we might represent routing when we're talking about how routing might work. And think about the validity of routing. So if we think about how we might draw out a packet, the path a packet might take through a network, then we could draw this kind of tree. We can take a graph and like the one we've drawn up here on it, we can add arrows that show us which the next hop of each specific devices for a specific destination. If we look, we've only got one destination. It's A over here. So if we're going to draw out what the result of a routing decision is, then here we're saying two chose to forward to R. Three or six here chose to forward to right for this particular destination. We're going to make a simplification here and we're going to say one destiny on one next hop per destination. When we come on a bit later in the semester and we talk about something like data center apologies, we might question that assumption, but we'll say right now there's only one. What we'll do is we'll therefore draw on one arrow per node. Because each node, each router can only decided to one destination in one particular way. And one thing we can know about this is when paths meet, they never split. Because for example here, if one forwards to 4.3, forward to four for this destination A, then R four isn't making a decision based on anything other than this is going to A, which means that the two paths can't then diverge. No other destination is, no other field is being considered to be able to figure out. To make it split, it's only going to use the destination. So we can always draw these things as sort of converging trees when we draw this out. The set of all of the paths. So this is where we think about every to this single destination creates this directed delivery tree which must cover every node. Because we want every source node to be able to have reachability to this end host that we're considering. What this is, is an oriented spanning tree. A spanning tree is a tree that touches every node and it is oriented towards the destination. If we now have a way to draw out rooting, this gives us a way to be able to draw out rooting in a particular network. We said a bit earlier that we might want to think about good routing, where we said it might be a short path, but the notion of goodness is flexible. We can say that there might be very different things that we optimize for. But we say one thing that's probably the minimum definition of good is that packets reach their destinations. That's useful to be able to reason about. Scott Shenker, who I think used to teach his class has expresses this as routing state validity. This term is used at Berkeley. I didn't actually know this term before I read these slides, but it's something that is useful to reason about. I probably should have known. Before I read these slides, we'll think about this idea of routing state validity. When we think about the state, the local routing state is the table at a single router. When we look at that, we can't really evaluate it for validity because we don't really know anything to do with, if we choose this specific next top, we don't know anything about how it's connected or anything about whether it's actually closer to the destination. So we can only think about this in terms of the global picture. Just to explain that further, if we're looking at R two table here, we say oh for a port three is the next thing. We don't know anything about whether that state is valid, we don't know whether it'll get packets to our destination. So we can't really look at this, so we have to look at some global way of taking the whole topology of the network. To do that, we need to look at the global state. So we need to look at the collection of the tables in all the routers. That allows us to determine what path the packets takes. We consider that routing valid if it produces forwarding decisions. The routing is valid if the forwarding decisions result in us always delivering packets to their destinations. The goal of routing protocols, which is the way that we compute paths and the way that we exchange information to build that topology is to be able to compute valid state. We're going to eventually talk about how to actually do that, but we'll start off by thinking about this validity to start with, well, given some state, how do we actually tell that it's valid? And basically what we want is a correctness condition for rooting something that lets us know whether routing is correct or incorrect. We'll use which statement, which is both necessary and sufficient. Global routing is valid if and only if for each destination there are no dead ends and there are no loops. Okay, that's useless unless we know what dead ends and loops are. So let's think about that. A dead end is where there's no outgoing link for a specific destination, there's no next top specified. And that means that when a packet arrives at that device, because it doesn't know what the next top is or the, or the port to send it out of, it's just going to drop that packet, the destination of the packet itself. Like if we're sending a packet to A and it arrives at A. Well, A doesn't do this, it doesn't have nextop because itself is the destination. So we'll kind of relax this and say, well, you're not a dead end if you're actually the destination of the packet. Hosts are generally dead ends in our picture because they generally don't forward packets. There's cases where they might do, but we'll simplify this and say they're just going to not forward packets for us. Okay, so we now say, well, a dead end is where a packet doesn't get forwarded. A is a bit more self explanatory, right? Is where a packet cycles around the same set of nodes. And if forwarding is deterministic, if it only depends on the destination address, then the package is going to keep going round and round. Because we said once we got on a path there was no way to get off because we're always just look at the same destination. And in some cases that meant there was the merging of the trees. In other cases, if we're on a loop, then that tree is just going to loop round and round. So let's think about why is this condition necessary? If there were, sorry, if there were dead ends then you won't reach the destination. Because we've said by definition the dead end is where you aren't, the packet is not forwarded but didn't reach the destination. So pretty obvious and if you run into a loop then you never reach the destination again. Because you'll just keep looping round and round because the destination address doesn't change if the destination was part of the loop. Well, it wouldn't have forwarded the packet because we said destinations don't need to for their own packet. So it's necessary for routing to be valid that there are no loops and no dead ends. But is it sufficient enough to say if there are no loops and dead ends, then the routing is validity? Let's assume that the routing state has no loops or dead ends. We know that the packet can't hit the same node twice because that'll be a loop. If it ever ends at back a device, then we've just closed the loop. If there are no loops, then you can't hit the same device twice. The packet can't stop until it reaches the destination. We said nobody in the network. No router in the network is dead ending. Therefore there must be a forwarding entry. The packet must keep wandering through the network, somehow hitting different nodes. There's only a finite number of nodes that it can visit. It'll eventually hit the destination, even if it just randomly wanders through without a loop or a dead end, it will eventually hit some destination, it must do so in this case we can say because we have no loops and dead ends, then we also have valid routing state. Okay, so we've got a nice condition. How do we actually put it to use? A couple of quick notes. I mentioned this, hosts don't generally participate in routing. The general case for a host is to be connected to one router, and thus it doesn't really need to understand anything other than the topology. It has essentially a default route which says for anything I'm trying to send, to just send it to that guy that I'm connected to. And he'll figure out where to send it and that will exist for everything that they're not the destination for. This means that we're hosts a uninteresting in terms of when we're thinking about routing because all they do is send packets to the device they're directly connected to or just sync them if they're the destination. And they don't ever have forwarding entries, so we can just ignore them. But routers themselves might be legal destinations depending on some of the network design. It might be that you do want to send packets them and IP routers that we'll talk about can be. But it's pretty unlikely you want to talk to a specific router. Like if you're trying to get to some application or you're trying to do a Google search or something like that, it's not the router that's providing that. So it's not really very common. Host to host communication is essentially much more common. So we'll often just ignore the routers as destinations. But you can think of all routers as a potential source of packets because they know they might have hosts connected to them, which means that they would need forwarding entries. We'll actually work on a project later in the semester that looks at case where you do want a router to be a legal destination and look at some of the use cases for that. We're going to go back and look at how we verify the validity. What we're going to do is we're going to focus only on, sorry, if the packet arrives at the end host, The end host that the packet is destined for. Yeah, I mean, at that point there must be, we can say for that destination the routing is valid. We don't know it's valid from every source. We just because we only have a sample size then of one packet. So when we're going to look at this, we're going to look through and look at all the potential sources of packets which are all the routers. But if we're just looking at one packet, we don't know. We have no information from whom it came. So it could have just come to the router we were also connected to. So we can't really assert anything about the global validity just from one packet. So let's look at that. We're going to ignore all the hosts. We're going to just think about one destination, mainly because it's a lot easier for us to look at. What we're going to do is go through and mark each outgoing port with an arrow like the way that we represented next top. We know there can only be one of these arrows at every router, every node, because we've said that it's destination based routing. So we've said that there can only be one destination for every single, for every destination. Then we're going to go and eliminate all the links that have no arrows on them to simplify the graph. Down to show us what that tree looks like, we're going to look at what's left and we'll say that the state is valid if and only if the resultant graph, when we've pruned all these links and we've taken these links, the only the links with arrows on is a directed delivery tree. So essentially a directed spanning tree. Someone that touches all nodes where the edges point towards the destination. Okay, here's the network we're going to think about the hosts, are these things in circles, the routers, these things that are in squares. And we're going to specifically think about the state going to A. To start off, we're just going to ignore all the other hosts, and so we're going to remove them from the graph. We're then going to go add these arrows that show us where each root forwards. In this case, this root at the top is going to forward towards this one here. And you can see that as we said, when they converge, they don't split. So we only get one arrow that's being sent from this rooter downstream. We then we're going to go and prune all the links. We're going to remove all the links that don't have an arrow on them. Here we can see that this is a spanning tree that converges on A. It touches every node. There's no node that doesn't have an arrow. It all is directed towards the destination. We can say here that rooting here is valid. Now for this case, this case valid, I agree, this guy is a dead end, right? If there were a line here, then we would say, okay, this guy is forwarding. But here because there's no outgoing arrow, then this is a dead end. It doesn't have any route towards the destination. What about this one? This one's easier to see exactly up here. Once packets are in here, wherever the end they're going to go round this loop and they're never going to exit it again. We can't have any loops for there to be valid routing. This is a pretty nice way for us to reason about validity of routing because we can say, well, if there's not an outgoing arrow then we can't reach the destination, that's a dead end. Loops are pretty obvious because they're subgraphs that are just disconnected from the rest of the graph to say for every destination. We just need to go and do the same process but for multiple destinations. Here we only look to A. Okay. Now we're going to try and experiment. To think a little bit about routing. We're all going to work together. You're going to talk to your neighbors. We're going to define your neighbors as the people sitting in front of you, behind you, left and right. And you might not have neighbors on all sides. There's some three seats. It's pretty busy though. And everyone's going to have a magic number. Your magic number is going to be initially infinity, and your aim is to get as low a magic number as possible. And if your neighbor offers you a lower number, what you should do is you should take it, It's now your magic number. And immediately then offer your magic number plus one to all of your neighbors. And try and remember who gave you your magic number. If somebody offers you a bigger number, a greater number, ignore it. Let's just go through that because there was a bunch of instructions it's easier to look at. Encode your number is infinity to start with, you're going to offer your number plus one to everybody. So you're going to initially offer infinity. And then until we terminate this experiment, then if a neighbor offers you a lower number, that's now your number, so you should accept it and then offer your number plus one to everybody else. Okay. We could oh yeah, and you should remember who you gave you your number. Okay. Okay. Let's see how this worked. So let's stop. But remember your number and who gave it you. So now, so remember your number and who gave you the person who gave you your current number is your best friend. Unfortunately, because this is the way this works, your best friend is your best friend is never going to be reciprocally your best friend, if that makes sense. So you're never your best friend's best friend. Sorry. Much better On this slide, if you forgot who gave you a number, it's pretty easy to find out. You must have at least one neighbor who has your number minus one and pick any of those people to be your best friend. Okay? So now what we're going to do is if somebody gives you an envelope, you need to give it to your best friend. If your best friend gives you an envelope, they're probably confused. But hopefully that's not going to happen because you've all done a great job of remembering who your best friend is. Right. I'm going to give you an envelope, and I'm going to give you an envelope, sorry. Oh, no. We'll talk about the likelihood this goes right, is about zero. Okay? So, don't worry about it. I'm going to give you an envelope. I would have thought even the one on the one on this column would have worked. Se is your number. Okay. So, not everybody. Where are the envelopes? Did you hand it to your best friend? Did you have a best friend? Oh, I'm really sorry about that. Unfortunately, this is a CS class, so I can't help this. One didn't get anywhere. One also didn't get anywhere. Interesting. Put your hand up if you have a non infinity number. Oh man. There's a very glossy layer like you're kind of all wrong, that same layer. Okay, So hand the envelope down till it gets to somebody who has a number. If you have a number that is not infinity handed your best friend. I was clearly too ambitious. Starting at the top. Oh my gosh. I'm so sorry. You can open the envelope. Okay. So where did the other two get to? We have oh, two. There were three. Yeah. Two out of three has. Okay. So all these envelopes should have got to Sarah. This one didn't. I mean, to start with, none of them got to Sarah. So, we had had some debugging to do on this exercise, so we had no luck. But that's fine. We can still debug this exercise. So how should they have got to Sarah? Well, everyone should have started out with infinity. I then gave Sarah zero, and she then added one onto it and handed it to everybody else. Then the next stage should have hit two and then it should have carried on. So that we essentially ended up with this directed grab that ended up at Sarah when we actually put the packets in the envelopes. Then, because you had a next top and a destination that was just based on this number, then you should have gone down the slope and ended up at Sarah, which they eventually did, once I had gamed the system a little bit and told you not to hand O to someone who had a number. This generalizes to many different destinations. Like, if I'd given Sylvia zero as well, then as long as you'd remember your number towards Sylvia and the number towards Sarah, then you would have we would have been able to have the same thing. So what could or did go wrong or everything? So there are a bunch of things that can go wrong here. You know, you can be sitting too far apart which means the networks partitioned. Probably. When I didn't mention that numbers go across the aisles, then that was a partition between, you know, we would have ended up with three separate networks. You could have forgotten your magic number, you could have misremembered or mis updated your magic number. Forgetting it would be like a route rebooting and coming up and having no view of what the topology looked like. Misremembering or mis updating it as an implementation bug neighbor didn't hear, maybe there's like a sound barrier at the middle of the room, which is why we stopped at a certain layer. Someone might have left. After a neighbor offered, after you'd been given a number by them, the person could have left. Which then would have led in you not having the place you got the number for. Someone could have lied about the number. Somebody could have just decided that they wanted to be zero and then made the destination converge on them. Is there anything else that could have gone wrong? Yeah, we could have basically terminated this experiment a bit too early and not looked at whether the packets are actually going to go. This algorithm is at the asynchronous version of the Bellman Ford algorithm. And we're going to use this next time to think about a real routing protocol. But it's really important that we think about these two things, the distributed nature of it and the asynchronous nature. Because we know about networks that they are distributed, right? They've got to be geographically in different places and there's many independent devices which are the routers that build up that network. And they're asynchronous, the components don't operate in sync. Like, we didn't do anything here to say like, okay, we're now going to do this, we just said, let's go, let's go and inject a number and then you're going to chat with each other until hopefully the network figures out. This seems promising because, you know it was an algorithm whereby we should have been an algorithm whereby we added a zero over here and everybody in the room got to know that, got to know who their next hop was to be able to reach Sarah eventually. Now, of course, we had some bugs, so we didn't quite get there, but we'll talk about this more next time. This class of routing protocols, we've been thinking about the abstract graph and how you saying, oh, there is a routing protocol that side, this class of protocols which are the approaches for figuring out routing. They're called distance vector protocols. So basically adjacent routers exchange a vector that's a distance to a destination. Actually they really exchanged a destination distance tuple. This approach was used in the Pet precursor to the Internet as long ago as 1969. And then in Zerox route D, which was in Berkeley Eunux in 1983 standardized this and it's, it's called Routing Information Protocol. Extremely creative naming. It was updated in 94 and in 97 for different things. It's a prototypical disinspector protocol. I've deployed it exactly once in my life, so it's not that common anymore, But we're going to talk about it because it gives us a foundation in a type of routing protocol that's pretty important. And there's some alternative disinspector protocols. Eigrp is a Cisco proprietorye and then there's one that's been used in, in center networks called Barbel recently. So I think we're a little early, but next time we're going to talk about disinfection protocols. We're also going to talk about a different type of routing protocol called Link State. The quiz is now open now. There we go.